1.innodb和myisam区别
innodb支持事务myisam不支持（安全恢复）
innodb不支持fulltext类型索引，不存储数据总条数，count（*）操作会进行全部扫描，
myisam只需要取出数据就行，当含有where条件时，都需要全表扫描。
innodb支持行锁，myisam不支持。
innodb支持外键，myisam不支持。
delete from table innodb不会重建表，会一行一行删除，myisam会重建表
innodb是聚集索引，Mysiam是非聚集索引，聚集索引的叶节点是数据节点，
非聚集索引的叶节点仍然是索引节点，两者都是B+tree
innodb适合频繁修改已经安全性较高的应用，mysiam适用于查询插入为主的应用。
5.5之后默认引擎是innodb
mysiam索引和数据是分开的，索引是压缩的，可以更换利用内存。
innodb数据存储在共享表空间，对主键查询性能高于mysiam
Mysiam效率简单效率上优于innodb，小型应用考虑Mysiam，提供高速存储和检索，
大量select可以使用，存储成文件，跨平台，
博客和新闻，innodb适用于事务操作，大量insert和update，一般默认
2.数据库的三范式:
1NF每一列都是不可分割的原子数据项
2NF实体的属性完全依赖于主关键字，要求实体有唯一性标示
3NF任何主属性不依赖于其他的非主属性，不能有冗余字段，任何字段不能由其他
字段派生出来
3.数据库事务的四个特性:
1.原子性：事务的操作要么全部完成，要么全部不完成
2.一致性：事务开始之前或者结束之后，数据库的完整性不被破坏
3.隔离性：两个事务，串行话，同一时间仅有一个请求作用于同一数据
4.持久性：事务完成后，该事务对数据库进行的操作永久保留，不回被回滚


2.B+tree索引和hash索引的区别
hash索引可以一次定位，效率高。b+tree需要从根结点到叶子节点，需要多次io访问。
hash索引只能满足in = 查询，不能范围查询，hash索引遇到大量hash值相等的情况下，
hash冲突，性能不一定比B+tree高，hash由于不同索引键存在相同hash值，即使满足条件
也要回表扫描。innodb默认是b+tree索引。
hash索引排序不能完成排序已经like模糊查询。需要全表扫描。hash索引不支持联合
索引的最左原则。
等值查询，hash索引有优势，范围检索不行。索引大多数场景都是用b+tree索引。
b+tree索引原理
b+tree是一种多路平衡查询树，节点是天然有序的（左子节点小于父节点，父节点小
于右子节点），索引范围查询不需要全表扫描
hash是哈希表key-value存储，索引没有顺序关系。

存储引擎会先在索引中找到对应的值，然后根据匹配的所有找到对应的行数据

3.聚集索引和非聚集索引区别
根本区别是表记录的排列顺序与索引排列顺序是否一致。聚集索引顺序一致，查询效率快，
但是修改慢，插入的时候会对数据页重新排序。类似字典a-z
非聚集索引不一定一致，层次多，不会重排。类似于字典的偏旁部首检索。
频繁更新不使用聚集索引。
主键索引叶子节点上是整行数据，非主键索引叶子节点是主键的值，
非主键索引查询需要回表。
覆盖索引索引树上直接提供结果不需要回表。
B+树可以利用索引最左前缀，定位记录。所以我们建立联合索引的原则1，
如果调整顺序可以少维护索引，优先考虑，2.空间也就是字段大小
5.6之后根据索引下推，对索引上字段先做判断，减少回表次数。

索引key为什么长度不能太长
key太长会导致一个页中能够存放的key的数目变少，导致索引树的页数变多，
索引层次增加，影响查询效率。

普通索引和唯一索引的区别
查询效率差别不大，插入的时候，如果目标页在内存中，差别不大，不在内存中，
唯一索引需要把数据页读入内存判断冲突,再修改，而普通索引
更新记录再changebuffer中，性能明显提升。尽量使用普通索引。
把change buffer开大。
change buffer 使用于写多读少的场景

字符串字段加索引 前缀索引 倒序存储 hash字段

索引类型：
普通索引 唯一索引 主键索引 联合索引 全文索引（mysiam才有只支持英文）
froce index 可以强制索引。

索引生效问题：
1.最左前缀（a，b，c） a ab abc 生效
2.like 查询 前面 不能有%
3.is null 可以使用
4.or 前面有索引后面没有，索引不生效
5.列类型是字符串需要加引号
6.增加条件的范围取值

6.数据库索引是数据库管理系统中一个排序的数据结构，用于快速查询更新数据。

设置索引的优点：
1.创建唯一性索引，可以保证每一行数据的唯一性
2.加快数据检索速度
3.使用分组和排序语句检索时，减少分组和排序的时间
设置索引的缺点：
1.增加数据库的存储空间
2.插入和修改数据要花费较多的时间
3.创建索引和维护索引要耗费时间，随数据量的增加

建立索引的原则:
1.经常用于作为查询条件及搜索的列
2.经常用于连接的列，主要是外键
3.经常根据范围进行搜索的列
4.经常排序的列范围查询
5.经常使用where子句的列
6.选择唯一性索引，快速定位记录
7.最左匹配原则，一直向右匹配到(><betweenlike)停止匹配
8.使用前缀来索引，比如text和blog
不适合建立索引：
1.查询少的列
2.很少数据值的列，比如性别和状态
3.修改性能大于检索性能
4.text，image，bit数据类型，数据量要么很大，要么很小
常用索引的类型和区别：
1.普通索引：没限制，值可以为空，可以重复，一个表中可以有多个
2.主键索引：特殊的唯一性索引，一个表只能有一个索引，值不能为空，不能重复
3.唯一性索引：关键字不能重复
4.全文索引：搜索引擎常用的关键技术

7.数据库优化的思路：
show processlist；explain
sql方面
1.尽量避免使用！=或者<>,会放弃索引
2.尽量避免对null值进行使用，num类型默认为0，string为‘’
3.where子句代替having，having检索之后对结果集进行过滤
4.in的值不能太多
5.避免select *尽量指明字段
6.如果只需要一条，limit 1
7.如果其他条件没有索引，避免or
8.避免like %name ，会放弃索引，用全文索引
9.联合索引的最左原则
10.避免隐式类型转换
11.尽量使用整型表示字符串比如ip，
12.尽可能选择小的数据类型指定短的长度

数据库方面.
1.建表的时候遵循三范式
2.拆分表：水平拆分(多种相同的表存储同一类型的数据)根据某个字段进行模运算哈希运输 
serverid userid 和 union操作 或者建议一个中间表 
垂直拆分(分割字段)，一个常用信息一个热点信息 join操作
通过性别和状态
3.分区，hash，range，key，list分区 分成多个表文件 1024个分区
4..mysql集群，主从复制，读写分离


explain 分析

mysql的关联update


mysql查询优化
记录慢查询日志分析慢的方法 pt-query-digest 云服务会直接有的
show profiles sql执行时间show status sql执行次数
show processlist 进程explain 分析sql语句 desc  
查询不需要的记录 limit多表关联返回全部列select * 索引覆盖
重复查询相同数据可以做缓存是否扫描额外数据通过索引优化已经sql修改
修改表的结构，空间换时间切分查询 
count（*） 不要count列表 增加汇总表 增加缓存
关联查询 on上有索引 group by order by 只使用一个表的字段
group by 如果不需要排序可以加order by null mysql不会再进行文件排序
limit 记录查询上次id加where条件unionall代替union



4.主从复制
同步复制 异步复制 半同步复制。通过binlog

5.mysql高并发环境解决方案
分库分表：水平分表：按照某个字段的某种规则做拆分，分割后可以降低查询时 
垂直切分按照模块切分到不同的数据库上去
集群方案
主从复制 读写分离 

6.数据库崩溃数据如何恢复恢复
undo log
redolog
binlog 主从复制 


8.数据量太大，curd比较慢，如何优化
表拆分，减少单笔字段数量优化表结构
保证主键有效的情况下，检查主键索引的字段顺序，使得查询语句中条
件字段顺序和主键索引顺序保持一致
在单表的条件下，从sql语句索引优化提交检索速度

9.高并发下如何做到安全的修改同一行数据
使用悲观锁 缓存队列fifo先进先出 使用乐观锁

10.关系数据库采用的什么类型数据结构
二维表（非线性数据结构）存储，关系-》二维表，元祖-》二维表中的行，分量-》
二维表中的列
B+tree索引-》树形数据结构  hash索引-》集合数据结构

mvc 
model 数据模型层 view 视图层洁面 controller 控制器处理业务逻辑

tp yii ci 

单一入口工具原理

一个文件处理所有请求 通过参数加载控制器 模型  url不美观 可以统一安全检查  性能 
assign play smarty 





