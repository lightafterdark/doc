1.innodb和myisam区别
innodb支持事务myisam不支持（安全恢复）
innodb不支持fulltext类型索引，不存储数据总条数，count（*）操作会进行全部扫描，myisam只需要取出数据就行，当含有where条件时，都需要全表扫描。
innodb支持行锁，myisam不支持。
innodb支持外键，myisam不支持。
delete from table innodb不会重建表，会一行一行删除，myisam会重建表
innodb适合频繁修改已经安全性较高的应用，mysiam适用于查询插入为主的应用。5.5之后默认引擎是innodb
mysiam索引和数据是分开的，索引是压缩的，可以更换利用内存。innodb数据存储在共享表空间，对主键查询性能高于mysiam

2.B+tree索引和hash索引的区别
hash索引可以一次定位，效率高。b+tree需要从根结点到叶子节点，需要多次io访问。
hash索引只能满足in = 查询，不能范围查询，hash索引遇到大量hash值相等的情况下，hash冲突，性能不一定比B+tree高，hash由于不同索引键存在相同hash值，即使满足条件
也要回表扫描。innodb默认是b+tree索引。
hash索引排序不能完成排序已经like模糊查询。需要全表扫描。hash索引不支持联合索引的最左原则。
等值查询，hash索引有优势，范围检索不行。索引大多数场景都是用b+tree索引。
b+tree索引原理
b+tree是一种多路平衡查询树，节点是天然有序的（左子节点小于父节点，父节点小于右子节点），索引范围查询不需要全表扫描
hash是哈希表key-value存储，索引没有顺序关系。

存储引擎会先在索引中找到对应的值，然后根据匹配的所有找到对应的行数据

3.聚集索引和非聚集索引区别
根本区别是表记录的排列顺序与索引排列顺序是否一致。聚集索引顺序一致，查询效率快，但是修改慢，插入的时候会对数据页重新排序。类似字典a-z
非聚集索引不一定一致，层次多，不会重排。类似于字典的偏旁部首检索。频繁更新不使用聚集索引。
主键索引叶子节点上是整行数据，非主键索引叶子节点是主键的值，非主键索引查询需要回表。
覆盖索引索引树上直接提供结果不需要回表。
B+树可以利用索引最左前缀，定位记录。所以我们建立联合索引的原则1，如果调整顺序可以少维护索引，优先考虑，2.空间也就是字段大小
5.6之后根据索引下推，对索引上字段先做判断，减少回表次数。

索引key为什么长度不能太长
key太长会导致一个页中能够存放的key的数目变少，导致索引树的页数变多，索引层次增加，影响查询效率。

普通索引和唯一索引的区别
查询效率差别不大，插入的时候，如果目标页在内存中，差别不大，不在内存中，唯一索引需要把数据页读入内存判断冲突,再修改，而普通索引
更新记录再changebuffer中，性能明显提升。尽量使用普通索引。把change buffer开大。
change buffer 使用于写多读少的场景

字符串字段加索引 前缀索引 倒序存储 hash字段

索引类型：
普通索引 唯一索引 主键索引 联合索引 全文索引（mysiam才有只支持英文）froce index 可以强制索引。

索引生效问题：
1.最左前缀（a，b，c） a ab abc 生效
2.like 查询 前面 不能有%
3.is null 可以使用
4.or 前面有索引后面没有，索引不生效
5.列类型是字符串需要加引号
6.增加条件的范围取值

explain 分析





4.主从复制
同步复制 异步复制 半同步复制。

5.mysql高并发环境解决方案
分库分表：水平分表：按照某个字段的某种规则做拆分，分割后可以降低查询时 垂直切分按照模块切分到不同的数据库上去
集群方案
主从复制读写分离

6.数据库崩溃数据如何恢复恢复
undo log
redolog
binlog


8.数据量太大，curd比较慢，如何优化
表拆分，减少单笔字段数量优化表结构
保证主键有效的情况下，检查主键索引的字段顺序，使得查询语句中条件字段顺序和主键索引顺序保持一致
在单表的条件下，从sql语句索引优化提交检索速度

9.高并发下如何做到安全的修改同一行数据
使用悲观锁 缓存队列fifo先进先出 使用乐观锁

10.关系数据库采用的什么类型数据结构
二维表（非线性数据结构）存储，关系-》二维表，元祖-》二维表中的行，分量-》二维表中的列
B+tree索引-》树形数据结构  hash索引-》集合数据结构
