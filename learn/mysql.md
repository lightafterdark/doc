# <center>**mysql学习笔记**<center>

## **1.mysql基本架构**

![0d2070e8f84c4801adbfa03bda1f98d9](../0d2070e8f84c4801adbfa03bda1f98d9.png)

1. 连接器<br>
   连接器负责跟客户端建立连接，获取权限和管理连接，命令如下:**mysql
   -h$ip -P$port -u$user -p**<br> 连接成功后，如果没有后续操作,连接处于空闲，**show
   processlist**
   可以查看，长时间没动静，连接器会自动断开。时间由参数**wait_timeout**控制得,默认8小时<br>
   长连接是指连接成功后，如果有客户端持续请求，则一直使用同一个连接。<br>
   短链接是指每次执行完很少得几次查询之后就断开连接，下次查询重新建立连接。<br>
   建立连接过程比较复杂，尽量使用长连接，但是全部用长连接，mysql占用内存会涨得比较快。
   原因:mysql执行过程中临时使用得内存是管理在连接对象里面得，资源会在断开
   连接才释放，所以，长期积累下来，导致内存占用太大，被系统杀掉，也就是mysql异常重启。
   解决方案:(1)定期断开长连接，使用一段时间或者程序里面判断执行一个占用内存得大查询后，断开连接，后面需要查询再重连
   (2)mysql5.7或更新版本,执行比较大得操作后，通过执行**mysql_reset_connection**来重新初始化连接资源。这个过程不需要重新连接和权限验证，但是会恢复到
   刚连接得状态

2. 查询缓存<br>
   mysql会到缓存中查询之前是否执行过这条语句。之前语句得执行结果会被以kv存在内存中。命中缓存直接返回，效率会很高。<br>
   但是缓存查询，弊大于利。查询缓存失效非常频繁，只要有对一个表的更新，表上所有查询缓存都会被清空。所以对于经常更新得表，
   查询命中率非常低，除非静态表，很久才更新一次，比如系统配置表，这张表上得查询才适合使用查询缓存。<br>
   可以将**query_cache_type设置成 DEMAND**，对于默认得sql都不使用缓存查询。对于需要使用得语句，用**SQL_CACHE**显示指定使用缓存。例如:**select
   SQL_CACHE * from T where
   ID=10；**注意，从8.0开始，mysql将查询缓存功能删除了。

3. 分析器<br>
   真正执行sql语句，分析器会做词法分析，分析sql语句里面得字符串分别是什么，代表什么，然后做语法分析，判断sql语句是否满足mysql语法。

4. 优化器<br>
   优化器是在表里面有多个索引得时候决定使用哪个索引，或者多表联查，决定表得访问顺序。

5. 执行器<br>
   开始执行得时候，先判断下你对这个表有没有执行查询得权限。有权限继续执行。


## **2.mysql日志模块**

1. redo log(重做日志InnoDB引擎特有的日志)<br>
   WAL技术全称是Write-Ahead Logging。先写日志再写磁盘。具体来说，有记录需要更新时，
   InnoDB引擎把记录写到redo log，更新内存，更新就算完成。同时，InnoDB引擎会在适当得时候把操作记录更新到磁盘
   ，一般是系统空闲得时候做。<br>
   有了redo log，InnoDB可以保证即使数据库发生异常重启，之前提交得记录不会丢失，称为crash-safe。<br>
   **innodb_flush_log_at_trx_commit**设置为1的时候，表示每次事务的redo log都直接持久化到磁盘，可以保证异常重启数据不丢失。

2. binlog(归档日志) <br>
   这个日志是mysql Server层自己得日志。最开始mysql没有InnoDB引擎，自带得是MyISAM引擎，
   MyISAM没有crash-safe得能力，只能用于归档。InnoDB是另外一个公司以插件形式引入mysql得。

   **sync_binlog**设置为1，每次事务的binlog都持久化到磁盘，保证异常重启binlog不丢失

3. 区别<br>
  （1）redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的
   Server 层实现的，所有引擎都可以使用。<br>
  （2）redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog
   是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c
   字段加 1 ”。<br>
  （3）redo log 是循环写的，空间固定会用完；binlog
   是可以追加写入的。“追加写”是指 binlog
   文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。<br>

4.  update语句执行流程
    ![2e5bff4910ec189fe1ee6e2ecc7b4bbe](../2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

5.  两阶段提交，为了让两份日志直接的逻辑一致。1。恢复临时库2。需要扩容的时候，也是全量备份加上binlog实现

## **3.事务**
    事务是引擎层实现的，MYSAIL引擎不支持事务。
    ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

1. 隔离性<br>
    当有多个事务同时执行，就可能出现脏读，不可重复读，幻读的问题。<br>
    隔离的越严实，效率越低。事务隔离级别包括:<br>

    (1)读未提交:一个事务没提交时，它做的变更就可以被别的事务看到<br>
    (2)读提交:一个事务提交之后，它的变更才可以被其他事务看到<br>
    (3)可重复读:一个事务执行过程中看到的数据，总是跟这个事务启动时看到的数据一致<br>
    (4)串行化:对于同一行记录，写会加写锁，读会加读锁，当读锁和写锁冲突时，
    后访问的事务必须等前一个事务执行完成，才能继续执行<br>

    配置方式是**transaction-isolation**的值设置成
    **READ-COMMITTED**，不同隔离级别都有自己的使用场景。<br>

    可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。
    如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。<br>

2. 一致性<br>

3. 原子性<br>

4. 持久性<br>

5. 事务使用<br>
   尽量不要使用长事务，这些事务随时可能访问数据库的任何数据，所以事务提交之前，  
   所有可能用到的回滚记录都必须保留，导致占用存储空间。<br>
   事务启动方式:1.显示启动事务语句，begin和start
   transaction,配套的提交语句是commit， 回滚是rollback。2.set autocommit
   = 0 ，将这个线程的自动提交关掉。这个只要执行select
   语句，事务就启动了，不会主动提交。会持续存到主动执行commit或者rollback。所以最好
   set autocommit=1 显式启动事务。但是会多一次交互，可以使用**commit
   work and chain** 语法，提交并启动下一个事务<br>
   可以在information_schema 库的 innodb_trx
   这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务
    ```
    select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
    ```

## **4.索引**

1. 索引出现是为了提高查询效率，实现索引的方式确有很多钟。比如哈希表，有序数组和搜索树。<br>
   哈希表是一种kv存储数据的结构，不过多个key经过哈希函数计算会出现一个值的情况，拉链法解决。但是
   哈希表这种结构只使用于等值查询的时候，如果范围查询就要全部扫描。<br>
   有序数组等值查询和范围查询性能都很优秀。但是更新数据很麻烦，往中间插入记录就要挪到后
   面所以记录，成本太高。只适用于静态存储引擎。<br>
   二叉搜索树的特点是:父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。
   当日为了保持这棵树是平衡二叉树，更新的时间复杂度也是LogN。树也有多叉。大多数数据库存储不使用
   二叉树，因为索引不止存在内存中，还有写到磁盘。为了让一个查询尽量少地读磁盘，就必须让查询过程
   访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N 叉”树中的
   “N”取决于数据块的大小。<br>
   以 InnoDB的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4的时候，就可以存 1200 的 3 次方个值，这已经 17
   亿了。考虑到树根的数据块总是在内存中的，一 个 10亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3次磁盘。
   其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。N叉树由于在读写上的性能优点，以及适配磁盘
   的访问模式，已经被广泛应用在数据库引擎中了。<br>
   当然随着不断迭代优化现在有跳表，LMS等数据结构。

2. InnoDB 的索引模型<br>
   表都是根据主键顺序以索引的形式存放。称为索引组织表。使用了B+树模型，所以数据都是存储在B+树种的。
   B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最
   多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。B+树与B树最大
   的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。<br>
   索引类型分为主键索引（聚簇索引）和非主键索引:主键索引的叶子节点存的是整行数据，非主键索引的叶子节点内容
   是主键的值，也被称为二级索引。<br>
   主键索引和普通索引的查询有什么区别？非主键索引需要回表多扫描一棵索引树。回到主键索引树搜索的过程，称为回表。<br>
   B+树为了维护索引有序性，插入新值需要进行索引维护。所以自增主键的插入数据模式都是追加操作。比较好。
   比如身份证和id哪个做主键，身份证做主键的话，每个二级索引的叶子节点占用20个字节。显然，主键长度
   越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。<br>
   当只有一个索引而且是唯一索引的时候适合用业务字段做主键，这就是典型的kv场景。

3. 覆盖索引 索引树上直接提供查询结果，不需要回表，称为覆盖索引。
   由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

4. 最左前缀原则。
   B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。不只是索引的全部定义，只要满足最左
   前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N个字段，也可以是字符串索引 的最左 M 个字符。<br>
   建立索引时如何安排索引内的字段顺序。我们要考虑的是索引的复用能力。第一原则是，如果通过调整顺序，
   可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。第二原则空间，根据字段大小。

5. 索引下推

    ```
    select * from tuser where name like '张%' and age=10 and ismale=1;
    ```

    以市民表的联合索引为例。mysql5.6之前，只能找到符合姓名的id后，一个一个回表，
    到主键索引上找出数据行，再对比字段值。5.6之后的索引下推优化，可以在索引遍历过程中，
    对索引中包含的字段先做判断，过滤掉不满足条件的记录。减少回表次数。

6. 普通索引和唯一索引得区别
    在业务可以保证唯一得情况下。查询:普通索引查找到满足条件得第一个记录后，需要查找下一个记录，直到遇到不满足得为止，
    唯一索引，查到就会停止。查询性能基本没有差别。插入:当插入得记录要更新得目标页在内存中，唯一索引，找到位置判断是
    否重复，然后插入这个值，普通索引，找到位置，插入，性能基本一样。当插入记录要更新得目标页不在内存中，唯一索引，
    需要将数据页读入内存判断冲突，普通索引，更新记录在change buffer，性能明显提示。<br>
    change buffer 得使用场景:写多读少得场景。如果修改之后立马访问，增加了维护代价。起到了副作用。节省得是随机读磁盘得io消耗<br>
    尽量使用普通索引。<br>
    如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。
    而在其他情况下，change buffer 都能提升更新性能。<br>
    当有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，应该特别关注这些表里的索引，
    尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。


7.  mysql选错索引
    选错索引得原因是没准确地判断出扫描行数。可以用**analyze table t**重新统计索引信息。<br>
    （1）force index 可以起到矫正索引得作用,但是不够优雅，而且麻烦。<br>
    （2）修改语句，导致mysql使用我们期望得索引。<br>
    （3）新建一个更合适得索引，提供给优化器做选择，或者删掉误用得索引。

8.  字符串字段加索引
    (1)使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。<br>
    建立索引时关注区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。
    因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。<br>
    **mysql> select count(distinct left(email,4)）as L4 from SUser;**用来查看这个列上有多少个不同的值。<br>
    使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。
    (2)倒序存储
    (3)使用hash字段
    倒序存储和hash字段这两种方法的异同，相同点是都不支持范围查询。不同点：1.倒序存储方式在主键索引上，不消耗额外空间，
    hash字段的方式需要增加一个字段。2.倒序每次都要调用一次reverse函数，hash需要调用crc32函数3.查询效率，hash相对稳定
    一些，倒序毕竟还是前缀索引，会增加扫描行数。

## **5.锁**

1.  全局锁<br>
     对整个数据库实例加锁，命令是**Flush tables with read lock
     (FTWRL)**之后其他线程的数据更新语句，数据定义语句，和更新类事务的提交语句都会被阻塞。<br>
     全局锁的典型使用场景是，做全库逻辑备份。在备份过程中整个库处于只读状态。<br>
     如果在主库上备份，备份期间都不能执行更新，业务要停。<br>
     如果在从库备份，备份期间从库不能执行主库同步过来的binlog，导致主从延迟。<br>
     但是不加锁的话因为不同表之间的执行顺序不同进而备份的时间不同。如果某个表在这个时间差
     中进行了更新并且成功被备份，而与其有关联的表已经在之前备份完毕已无法更新。此时就发生数据不一致。<br>
     官方自带的备份工具是mysqldump，当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，
     来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。前提是引擎要支持这个隔离级别。<br>
     既然要全库只读，为什么不用**set global readonly=true**的方式？<br>
     1.有些系统，readonly的值会被用来做其他逻辑，比如判断一个库是主库还是备库。<br>
     2.异常处理机制。如果执行FTWRL命令之后由于客户端发生异常断开，那么mysql会自动释放这个全局锁，整个库可以回到正常更新
     状态。而设置为readonly之后，客户端发生异常，数据库会一直保持readonly状态，会导致整个数据库长时间不可写，风险高。

2.  表级锁<br>
   （1）表锁。语法**lock tables ...read/write**,可以用unlock tables 主动释放锁，也可以再客户端断开的时候自动释放。<br>
   （2）MDL(metadata lock)访问一个表的时候自动加上。MySQL5.5版本引入，对表做增删改查的时候，加MDL读锁，对表做结构变更的
    时候，加MDL写锁。读锁之间不互斥，读写锁，写锁之间互斥。MDL锁在语句执行开始时申请，语句结束后不会马上释放，等到整个
    事务提交后释放。<br>
    如何给小表加字段?
    解决长事务，事务不提交，一直占着MDL锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的
    事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。如果是热点表，kill未必
    有用，比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，
    拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。
    **ALTER TABLE tbl_name NOWAIT add column ALTER TABLE tbl_name WAIT N add column**
3.  行锁<br>
    InnoDB支持行锁,MyISAM不支持。<br>
    在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
    这个就是两阶段锁协议。如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。<br>
    当并发系统中不同线程出现循环资源依赖，设计得线程都在等待别的线程释放资源时，会导致几个线程进入无限等待状态成为死锁。<br>
    出现死锁后，有两种策略:1.直接等待直到超时，通过参数**innodb_lock_wait_timeout**设置，但是时间值大无法接受，
    值小容易误伤。2.主动死锁检测。发现死锁后，主动回滚死锁链条中得某一个事务,主动死锁检测在发生死锁得似乎，
    可以快速发现，但是会有额外负担。<br>
    热点更新，很多线程同时更新同一行，死锁检测会发现没有所，但是会消耗大量得cpu资源。所以会看到cpu利用率很高，
    但每秒执行不了几个事务。解决方法:1.如果确保业务一定不会出现死锁，可以临时关闭死锁检测。意味着出现大量超时业务有损。
    2.控制并发度。可以做在数据库服务端中间件，也可以坐在mysql里面。基本思路就是，对于相同行的更新，
    在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。



## **6.mysql性能**

1.  mysql忽然会抖一下
    把内存中的数据写入磁盘。当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。
    内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。<br>
    哪些情况会引发数据库flush过程？1.innodb的redo log写满了2.系统内存不足3.mysql认为系统不忙的时候
    4.mysql正常关闭的情况。<br>
    第一种是要避免的，当出现这种情况，整个系统不能更新了。第二种是常态，innodb
    用缓冲池管理内存，缓存中的内存页有三种状态：1.没有使用的2.使用了并且是干净页3.使用了并且是脏页。对于
    长时间运行的库，位被使用页面很少，当要读入的数据页没有在内存中，必须到缓冲池申请一个数据页。这时候必须
    把最久不使用的数据页从内存淘汰。如果淘汰的是干净页直接释放，如果是脏页，必须先刷到磁盘，变成干净页才可
    以复用。刷脏页是常态，但是以下两种情况影响性能。1.一个查询要淘汰的脏页太多，导致响应时间长2.日志写满。
    所以innodb要控制脏页比例。
    innodb_io_capacity告诉innodb磁盘能力。
    innodb的刷盘速度要考虑两个因素：1.脏页比例2.redo log写盘速度。
    innodb_max_dirty_pages_pct 脏页比例上限。
    innodb中，innodb_flush_neighbors值为1的时候连坐机制，如果邻居是脏页会把邻居一起刷掉。值为0的时候只刷自己。
    ssd的话设置为0，机械硬盘设置为1可以减少很多随机io。8.0版本默认是0了。

3.  表删除一般数据，表文件大小不变？
    innodb_file_per_table设置为off表的数据放在系统共享表空间，跟数据字典存在一起。设置为on，表数据存储在一个
    以.ibd为后缀的文件中，5.66版本以后默认值是on。推荐设置为on，单独文件存放，drop table 系统直接删除这个文件，
    放在共享表空间中，表删除，空间不会回收。
    删除数据delete只是把记录的位置或者数据页标记为可复用，但是磁盘大小不变。不能回收表空间。<br>
    实际上插入数据如果不是按照索引递增顺序插入，也可能造成索引的数据页分裂。也会造成空洞。<br>
    重建表可以去除这些空洞。我们可以新建一个表，按照主键id递增把数据插入新表，然后用新表替换老表。可以使用
    alter table A engine=InnoDB 命令来重建表。5.5之前，这个临时表不需要创角，mysql自动完成。数据插入新表


