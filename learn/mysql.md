# <center>**mysql学习笔记**<center>

## **1.mysql基本架构**

![0d2070e8f84c4801adbfa03bda1f98d9](../0d2070e8f84c4801adbfa03bda1f98d9.png)

1. 连接器<br>
   连接器负责跟客户端建立连接，获取权限和管理连接，命令如下:**mysql
   -h$ip -P$port -u$user -p**<br> 连接成功后，连接处于空闲，**show
   processlist**
   可以查看，太久没有动静，连接器会自动断开连接。时间默认是8小时，由参数**wait_timeout**控制得。<br>
   长连接是指连接成功后，如果有客户端持续请求，则一直使用同一个连接。<br>
   短链接是指每次执行完很少得几次查询之后就断开连接，下次查询重新建立连接。<br>
   建立连接过程比较复杂，尽量使用长连接，全部用长连接，mysql占用内存会涨得比较快。
   原因:mysql执行过程中临时使用得内存是管理在连接对象里面得，资源会在断开
   连接擦释放，所有，长期积累下来，导致内存占用太大，被系统杀掉，mysql异常重启。
   解决方案:(1)定期断开长连接，使用一段时间或者程序里面执行一个占用内存得大查询后，断开连接，后面需要查询再重连  
   (2)mysql5.7或更新版本执行比较大得操作后，通过执行**mysql_reset_connection**来重新初始化连接资源。这个过程不需要重新连接和权限验证，但是会恢复到
   刚连接得状态

2. 查询缓存<br>
   mysql会到缓存中查询之前是否执行过这条语句。之前语句得执行结果会被以kv存在内存中。名中缓存直接返回，效率会很高。<br>
   但是缓存查询，弊大于利。查询缓存失效非常频繁，只要有对一个表得更新，表上所有查询缓存都会被清空。所有对于经常更新得表，
   查询命中率很低，除非静态表，比如系统配置表，很久才更新一次，这张表上得查询才适合使用查询缓存。可以将**query_cache_type
   设置成 DEMAND**，对于默认得sql
   都不使用缓存查询。对于需要使用得语句，用**SQL_CACHE**显示指定使用缓存。例如:**select
   SQL_CACHE * from T where
   ID=10；**从8.0开始，mysql将查询缓存功能删除了。

3. 分析器<br>
   真正执行sql语句，分析器会做词法分析，分析sql语句里面得字符串分别是什么，代表什么，然后做语法分析，判断sql语句是否满足mysql语法。

4. 优化器<br>
   优化器是在表里面有多个索引得时候决定使用哪个索引，或者多表联查，决定表得访问顺序。

5. 执行器<br>
   开始得时候，先判断下你对这个表有没有执行查询得权限。有权限继续执行。


## **2.mysql日志模块**

1. redo log(重做日志)<br> WAL技术全称是Write-Ahead Logging
   先写日志再写磁盘。具体来说，有记录需要更新时，
   InnoDB引擎把记录写到redo
   log，更新内存，更新就算完成。同事，会在适当得时候把操作记录更新到磁盘
   ，系统空闲得时候做。有了redo
   log，InnoDB可以保证即使数据库发生异常重启，之前提交得记录不会丢失，称为crash-safe

   **innodb_flush_log_at_trx_commit**设置为1的时候，表示每次事务的redo
   log  
   都直接持久化到磁盘，可以保证异常重启数据不丢失。

2. binlog(归档日志) <br> 这个日志是mysql
   Server层自己得日志。最开始mysql没有InnoDB引擎，自带得是MyISAM引擎，
   没有crash-safe得能力，只能用于归档。InnoDB是另外一个公司以插件形式引入mysql得。

   **sync_binlog**设置为1，每次事务的binlog都持久化到磁盘，保证异常重启binlog不丢失

3. 区别<br> （1）redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的
   Server 层实现的，所有引擎都可以使用。<br> （2）redo log
   是物理日志，记录的是“在某个数据页上做了什么修改”；binlog
   是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c
   字段加 1 ”。<br> （3）redo log 是循环写的，空间固定会用完；binlog
   是可以追加写入的。“追加写”是指 binlog
   文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。<br>

4. 两阶段提交，跨系统维持数据逻辑一致性常用的方案。

## **3.事务**

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

1. 隔离性<br>
   当有多个事务同时只需，就可能出现脏读，不可重复读，幻读的问题。<br>
   隔离的越严实，效率越低。事务隔离级别包括:<br>

(1)读未提交:一个事务没提交时，它做的变更就可以被别的事务看到<br>
(2)读提交:一个事务提交之后，它的变更才可以被其他事务看到<br>
(3)可重复读:一个事务执行过程中看到的数据，总是跟这个事务启动时看到的数据一致<br>
(4)串行化:对于同一行记录，写会加写锁，读会加读锁，当读锁和写锁冲突时，  
后访问的事务必须等前一个事务执行完成，才能继续执行<br>

**transaction-isolation**的值设置成
**READ-COMMITTED**，不同隔离级别都有自己的使用场景。<br>

2. 一致性<br>

3. 原子性<br>

4. 持久性<br>

5. 事务使用<br>
   尽量不要使用长事务，这些事务随时可能访问数据库的任何数据，所以事务提交之前，  
   所有可能用到的回滚记录都必须保留，导致占用存储空间。<br>
   事务启动方式:1.显示启动事务语句，begin和start
   transaction,配套的提交语句是commit， 回滚是rollback。2.set autocommit
   = 0 ，将这个线程的自动提交关掉。这个只要执行select
   语句，事务就启动了，不会主动提交。会持续存到主动执行commit或者rollback。所以最好
   set autocommit=1 显式启动事务。但是会多一次交互，可以使用**commit
   work and chain** 语法，提交并启动下一个事务<br> 可以在
   information_schema 库的 innodb_trx
   这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务

```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## **4.索引**

1. 索引出现是为了提高查询效率，实现索引的方式确有很多钟。比如哈希表，有序数组和搜索树。<br>
   哈希表是一种kv存储数据的结构，不过多个key经过哈希函数计算会出现一个值的情况，拉链法解决。但是
   哈希表这种结构只使用于等值查询的时候，如果范围查询就要全部扫描。<br>
   有序数组等值查询和范围查询性能都很优秀。但是更新数据很麻烦，往中间插入记录就要挪到后
   面所以记录，成本太高。只适用于静态存储引擎。<br>
   二叉搜索树的特点是:父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。
   当日为了保持这棵树是平衡二叉树，更新的时间复杂度也是LogN。树也有多叉。大多数数据库存储不使用
   二叉树，因为索引不止存在内存中，还有写到磁盘。为了让一个查询尽量少地读磁盘，就必须让查询过程
   访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N
   叉”树。这里，“N 叉”树中的 “N”取决于数据块的大小。以 InnoDB
   的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4
   的时候，就可以存 1200 的 3 次方个值，这已经 17
   亿了。考虑到树根的数据块总是在内存中的，一 个 10
   亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3
   次磁盘。其实，树的第二层也有
   很大概率在内存中，那么访问磁盘的平均次数就更少了。N
   叉树由于在读写上的性能优点，以及适配磁盘
   的访问模式，已经被广泛应用在数据库引擎中了。<br>
   当然随着不断迭代优化现在有跳表，LMS等数据结构。

2. InnoDB 的索引模型<br>
   表都是根据主键顺序以索引的形式存放。称为索引组织表。使用了B+树模型，数据都是存储在B+树种的。
   B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最
   多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。B+树与B树最大
   的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。<br>
   索引类型分为主键索引和非主键索引:主键索引的叶子节点存的是整行数据，非主键索引的叶子节点内容
   是主键的值，也被称为二级索引。<br>
   主键索引和普通索引的查询有什么区别？非主键索引需要回表多扫描一棵索引树。回到主键索引树搜索的过程，称为回表。<br>
   为了维护索引有序性，插入新值需要进行索引维护。所以自增主键的插入数据模式都是追加操作。比较好。
   比如身份证和id哪个做主键，身份证做主键的话，每个二级索引的叶子节点占用20个字节。显然，主键长度
   越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。<br>
   当只有一个索引而且是唯一索引的时候适合用业务字段做主键，这就是典型的kv场景。

3. 覆盖索引 索引树上直接提供查询结果，不需要回表，称为覆盖索引。
   由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

4. 最左前缀原则。 B+
   树这种索引结构，可以利用索引的“最左前缀”，来定位记录。不只是索引的全部定义，只要满足最左
   前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N
   个字段，也可以是字符串索引 的最左 M 个字符。<br>
   建立索引时如何安排索引内的字段顺序。我们要考虑的是索引的复用能力。第一原则是，如果通过调整顺序，
   可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。第二原则空间，

5. 索引下推

```
select * from tuser where name like '张%' and age=10 and ismale=1;
```

以市民表的联合索引为例。mysql5.6之前，只能找到符合姓名的id后，一个一个回表，
到主键索引上找出数据行，再对比字段值。5.6之后的索引下推优化，可以在索引遍历过程中，
对索引中包含的字段先做判断，过滤掉不满足条件的记录。减少回表次数。

6. 主键索引可以多个字段，有这么一个表

```
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

历史原因，需要a,b做联合主键。那为什么c上有索引，已经包含abc了，为什么还要建立ca，cb？

```
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

为了这两个语句，就需要建立ca，cb吗？ 主键 a，b 的聚簇索引组织顺序相当于
order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。 索引 ca
的组织是先按 c 排序，再按 a 排序，同时记录主键 索引 cb 的组织是先按 c
排序，在按 b 排序，同时记录主键 ca可以去掉，cb需要保留。


## **5.锁**

1. 全局锁<br> 对整个数据库实例加锁，命令是**Flush tables with read lock
   (FTWRL)**之后其他线程的数据更新
   语句，数据定义语句，和更新类事务的提交语句都会被阻塞。<br>
   全局锁的典型使用场景是，做全库逻辑备份。在备份过程中整个库处于只读状态。
   如果主库备份，备份期间业务要停。<br>
   如果从库备份，备份期间不能执行主库同步过来的binlog，导致主从延迟。<br>
   但是不加锁的话因为不同表之间的执行顺序不同进而备份的时间不同。如果某个表在这个时间差
   中进行了更新并且成功被备份，而与其有关联的表已经在之前备份完毕已无法更新。此时就发生数据不一致。<br>
   官方自带的备份工具是mysqldump，当 mysqldump 使用参数–single-transaction 的时候，
   导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。
   前提是引擎要支持这个隔离级别。

2. 表级锁<br>
3. 行锁<br>


